---
title: 你真的理解时钟吗？
date: 2021-04-28 01:30:34
tags: 
- 时钟
categories:
- 计算机基础
excerpt: 你真的理解时钟吗？
---

在实际编程中，超时判断作为无处不在，但是其内在的原理，所用的时钟你真的了解吗？本文将带你了解常用的时钟及相关调用，让你在面对时间跳变时心中有底！

## 时钟分类

首先需要了解时钟有哪几种，通过阅读time.h文件，可以发现共定义了12种时钟

```c++
#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
#   define CLOCK_PROCESS_CPUTIME_ID	2
/* Thread-specific CPU-time clock.  */
#   define CLOCK_THREAD_CPUTIME_ID	3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#   define CLOCK_MONOTONIC_RAW		4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#   define CLOCK_REALTIME_COARSE	5
/* Monotonic system-wide clock, updated only on ticks.  */
#   define CLOCK_MONOTONIC_COARSE	6
/* Monotonic system-wide clock that includes time spent in suspension.  */
#   define CLOCK_BOOTTIME		7
/* Like CLOCK_REALTIME but also wakes suspended system.  */
#   define CLOCK_REALTIME_ALARM		8
/* Like CLOCK_BOOTTIME but also wakes suspended system.  */
#   define CLOCK_BOOTTIME_ALARM		9
/* Like CLOCK_REALTIME but in International Atomic Time.  */
#   define CLOCK_TAI			11
```

总结一下，时钟按以下几个维度进行区分：

- 墙上时钟/单调时钟
- 系统时钟/线程进程时钟
- 是否只在Tick时更新
- 是否包含挂起时间
- ...

**<u>定义的12个时钟是以上一个或多个维度的组合</u>**

本文主要关注的是最常用的`CLOCK_REALTIME`和`CLOCK_MONOTONIC`的使用

`CLOCK_REALTIME`: 

- epoch是(00:00:00 GMT, January 1, 1970)
- 以整个系统时间流逝进行累加（和以在CPU上运行的时间累加CLOCK_PROCESS_CPUTIME_ID区分）
- 需要和NTP进行同步，因为地球自转并不总是86400秒且时钟存在误差

`CLOCK_MONOTONIC`:

- epoch是随机值，不具备具体含义
- 以整个系统时间流逝进行累加
- 无需和NTP同步，用来测量一段任务的持续时间（比如超时）



## 时钟相关调用

1. 线程阻塞，一段时间后恢复就绪
```c++
# glibc (POSIX)
sleep
```

| 层次（库）    | 函数            | 使用时钟        | 备注                                                         |
| ------------- | --------------- | --------------- | ------------------------------------------------------------ |
| glibc (POSIX) | sleep/nanosleep | CLOCK_MONOTONIC | POSIX规范推荐使用CLOCK_REALTIME，但是跳变不会影响sleep时间<br />Linux实现使用的是CLOCK_MONOTONIC |



2. 线程阻塞，等待唤醒或者超时
```c++
# glibc (POSIX)
pthread_cond_timedwait
pthread_cond_clockwait ## since glibc 2.30

# stdlibc++
std::condition_variable::wait_for
std::condition_variable::wait_until
```

| 层次（库）    | 函数                                  | 使用时钟        | 备注                                  |
| ------------- | ------------------------------------- | --------------- | ------------------------------------- |
| glibc (POSIX) | pthread_cond_timedwait                | 可选            | 通过pthread_condattr_setclock选择时钟 |
|               | pthread_cond_clockwait                | 可选            | since glibc 2.30                      |
| stdlibc++     | std::condition_variable::wait_for     | CLOCK_REALTIME  | since gcc10变为CLOCK_MONOTONIC        |
|               | std::condition_variable::wait_until   | CLOCK_REALTIME  | since gcc10变为CLOCK_MONOTONIC        |
| boost         | boost::condition_variable::wait_for   | CLOCK_MONOTONIC |                                       |
|               | boost::condition_variable::wait_until | CLOCK_MONOTONIC |                                       |



3. 线程阻塞，等待fd就绪或者超时
```c++
# System Call
epoll_wait // CLOCK_MONOTONIC

# libevent
int event_add(struct event *ev, const struct timeval *timeout);
  
# folly
bool EventBase::scheduleTimeout(
    AsyncTimeout* obj, TimeoutManager::timeout_type timeout)
```

| 层次（库）  | 函数                       | 使用时钟        | 备注                                      |
| ----------- | -------------------------- | --------------- | ----------------------------------------- |
| System Call | epoll_wait                 | CLOCK_MONOTONIC |                                           |
| libevent    | event_add                  | CLOCK_MONOTONIC | 传入relative time即可，背后用的是monotime |
| folly       | EventBase::scheduleTimeout | CLOCK_MONOTONIC |                                           |
|             | EventBase::runAfterDelay   | CLOCK_MONOTONIC |                                           |

## 总结

1. 线程阻塞，等待一段时间后恢复就绪
   - 使用`sleep/nanosleep`
2. 线程阻塞，等待唤醒或者超时
   - 使用boost::condition_variable
   - gcc10及以上，可以使用std::condition_variable 
3. 线程阻塞，等待fd就绪或者超时
   - folly::EventBase 放心食用



## 未来计划

后续如果遇到更多使用超时的场景会补充进来

另外关于以上三类情况背后系统调用里超时的实现原理后续会研究补充进来



## Reference

1. [[doc] nanosleep](https://man7.org/linux/man-pages/man2/nanosleep.2.html)

2. [[issue] std::condition_variable in bugzilla](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=41861#c20)

3. [[doc] pthread_condattr_setclock](https://linux.die.net/man/3/pthread_condattr_setclock)

4. [[code] pthread_cond_init](https://github.com/walac/glibc/blob/master/nptl/pthread_cond_init.c)
5. [[code] pthread](https://github.com/walac/glibc/tree/master/nptl)



## Appendix

### 代码片段详解：

通过以上调用的总结可以发现，使用上模糊的点主要是通过条件变量进行通信的场景，pthread上提供的最基本的函数是可选的，在std和boost分别采用了不同的时钟。下面直接看实现的代码：

#### pthread_cond_t

存储控制`pthread_cond_timedwait`使用时钟的数据结构`pthread_cond_t`：

```c++
/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters; // __nwaiters 存储了时钟的信息
    unsigned int __broadcast_seq;
  } __data; 
  char __size[__SIZEOF_PTHREAD_COND_T];
  __extension__ long long int __align;
} pthread_cond_t;
```

下面看`__pthread_cond_init`如何对该变量进行初始化，可见是通过读取`cond_attr.value`的倒数第二位设置到`__nwaiters`中

```c++
int __pthread_cond_init (cond, cond_attr)
     pthread_cond_t *cond;
     const pthread_condattr_t *cond_attr;
{
  struct pthread_condattr *icond_attr = (struct pthread_condattr *) cond_attr;

  cond->__data.__lock = LLL_LOCK_INITIALIZER;
  cond->__data.__futex = 0;
  cond->__data.__nwaiters = (icond_attr != NULL  // 看这里，设置nwaiters
			     ? ((icond_attr->value >> 1)
				& ((1 << COND_NWAITERS_SHIFT) - 1))
			     : CLOCK_REALTIME);
  cond->__data.__total_seq = 0;
  cond->__data.__wakeup_seq = 0;
  cond->__data.__woken_seq = 0;
  cond->__data.__mutex = (icond_attr == NULL || (icond_attr->value & 1) == 0
			  ? NULL : (void *) ~0l);
  cond->__data.__broadcast_seq = 0;

  LIBC_PROBE (cond_init, 2, cond, cond_attr);

  return 0;
}
```

最后看`pthread_condattr_setclock`如何设置`cond_attr`相应位为clock id，非常简单，保存在了大端序倒数第二位

```c++
// macro in libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h
/* The __NWAITERS field is used as a counter and to house the number
   of bits for other purposes.  COND_CLOCK_BITS is the number
   of bits needed to represent the ID of the clock.  COND_NWAITERS_SHIFT
   is the number of bits reserved for other purposes like the clock.  */
#define COND_CLOCK_BITS		1
#define COND_NWAITERS_SHIFT	1

int pthread_condattr_setclock (attr, clock_id)
     pthread_condattr_t *attr;
     clockid_t clock_id;
{
  /* Only a few clocks are allowed.  */
  if (clock_id != CLOCK_MONOTONIC && clock_id != CLOCK_REALTIME)
    /* If more clocks are allowed some day the storing of the clock ID
       in the pthread_cond_t structure needs to be adjusted.  */
    return EINVAL;

  /* Make sure the value fits in the bits we reserved.  */
  assert (clock_id < (1 << COND_NWAITERS_SHIFT));

  int *valuep = &((struct pthread_condattr *) attr)->value;

  *valuep = ((*valuep & ~(((1 << COND_NWAITERS_SHIFT) - 1) << 1))
	     | (clock_id << 1));

  return 0;
}
```

小结：

`pthread_cond_t.__nwaiters`存储了时钟信息，通过`pthread_condattr_setclock`和`__pthread_cond_init`进行设置

#### std::condition_variable

std如何初始化`pthread_cond_t`

```c++
typedef pthread_cond_t __gthread_cond_t; // 1. 核心是初始化pthread_cond_t这个类
 
/// condition_variable
  class condition_variable
  {
    typedef chrono::system_clock	__clock_t;
    typedef __gthread_cond_t		__native_type;

#ifdef __GTHREAD_COND_INIT
    __native_type			_M_cond = __GTHREAD_COND_INIT; // 2. 在这里进行了初始化
#else
    __native_type			_M_cond;
#endif
	······
	}

#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER
/* Conditional variable handling.  */
#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } } // 3. 具体初始化的参数
```

小结：

`std::condition_variable`的`pthread_cond_t.__nwaiters`初始化为0，即为CLOCK_REALTIME

#### boost::conditional_variable

boost如何初始化`pthread_cond_t`

```c++
class condition_variable
    {
    private:
//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        pthread_mutex_t internal_mutex;
//#endif
        pthread_cond_t cond; // 1. 核心是初始化pthread_cond_t这个类

    public:
      BOOST_THREAD_NO_COPYABLE(condition_variable)
        condition_variable()
        {
            int res;
            ```省略初始化mutex
            res = pthread::cond_init(cond); // 2. 在这里进行了初始化
            ```省略后续判断
        }
     }
     
     

```

```c++
namespace boost
{
    namespace pthread
    {
      inline int cond_init(pthread_cond_t& cond) {

  #ifdef BOOST_THREAD_INTERNAL_CLOCK_IS_MONO
              pthread_condattr_t attr;
              int res = pthread_condattr_init(&attr);
              if (res)
              {
                return res;
              }
              pthread_condattr_setclock(&attr, CLOCK_MONOTONIC); // 3. 设置了时钟attr为MONO
              res=pthread_cond_init(&cond,&attr);
              pthread_condattr_destroy(&attr);
              return res;
  #else
              return pthread_cond_init(&cond,NULL);
  #endif

      }
    }
}
```

小结：

`boost::conditional_variable`的`pthread_cond_t.__nwaiters`初始化为1，即为CLOCK_MONOTONIC