---
title: 你真的理解时钟吗？
date: 2021-04-28 01:30:34
tags: 
- 时钟
categories:
- 计算机基础
excerpt: 你真的理解时钟吗？
---

## 时钟分类

首先需要了解时钟有哪几种，通过阅读time.h文件，可以发现共定义了12种时钟

```c++
#  ifdef __USE_POSIX199309
/* Identifier for system-wide realtime clock.  */
#   define CLOCK_REALTIME		0
/* Monotonic system-wide clock.  */
#   define CLOCK_MONOTONIC		1
/* High-resolution timer from the CPU.  */
#   define CLOCK_PROCESS_CPUTIME_ID	2
/* Thread-specific CPU-time clock.  */
#   define CLOCK_THREAD_CPUTIME_ID	3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
#   define CLOCK_MONOTONIC_RAW		4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
#   define CLOCK_REALTIME_COARSE	5
/* Monotonic system-wide clock, updated only on ticks.  */
#   define CLOCK_MONOTONIC_COARSE	6
/* Monotonic system-wide clock that includes time spent in suspension.  */
#   define CLOCK_BOOTTIME		7
/* Like CLOCK_REALTIME but also wakes suspended system.  */
#   define CLOCK_REALTIME_ALARM		8
/* Like CLOCK_BOOTTIME but also wakes suspended system.  */
#   define CLOCK_BOOTTIME_ALARM		9
/* Like CLOCK_REALTIME but in International Atomic Time.  */
#   define CLOCK_TAI			11
```

总结一下，时钟按以下几个维度进行区分：

- 墙上时钟/单调时钟
- 系统时钟/线程进程时钟
- 是否只在Tick时更新
- 是否包含挂起时间
- ...

**<u>定义的12个时钟是以上一个或多个维度的组合</u>**

本文主要关注的是最常用的`CLOCK_REALTIME`和`CLOCK_MONOTONIC`的使用



## 时钟相关调用

1. 线程阻塞，一段时间后恢复就绪
```c++
# glibc (POSIX)
sleep
```

| 层次（库）    | 函数            | 使用时钟        | 备注                                                         |
| ------------- | --------------- | --------------- | ------------------------------------------------------------ |
| glibc (POSIX) | sleep/nanosleep | CLOCK_MONOTONIC | POSIX规范推荐使用CLOCK_REALTIME，但是跳变不会影响sleep时间<br />Linux实现使用的是CLOCK_MONOTONIC |



2. 线程阻塞，等待唤醒或者超时
```c++
# glibc (POSIX)
pthread_cond_timedwait
pthread_cond_clockwait ## since glibc 2.30

# stdlibc++
std::condition_variable::wait_for
std::condition_variable::wait_until
```

| 层次（库）    | 函数                                  | 使用时钟        | 备注                                  |
| ------------- | ------------------------------------- | --------------- | ------------------------------------- |
| glibc (POSIX) | pthread_cond_timedwait                | 可选            | 通过pthread_condattr_setclock选择时钟 |
|               | pthread_cond_clockwait                | 可选            | since glibc 2.30                      |
| stdlibc++     | std::condition_variable::wait_for     | CLOCK_REALTIME  | since gcc10变为CLOCK_MONOTONIC        |
|               | std::condition_variable::wait_until   | CLOCK_REALTIME  | since gcc10变为CLOCK_MONOTONIC        |
| boost         | boost::condition_variable::wait_for   | CLOCK_MONOTONIC |                                       |
|               | boost::condition_variable::wait_until | CLOCK_MONOTONIC |                                       |

3. 线程阻塞，等待fd就绪或者超时
```c++
# System Call
epoll_wait // CLOCK_MONOTONIC

# libevent
int event_add(struct event *ev, const struct timeval *timeout);
  
# folly
bool EventBase::scheduleTimeout(
    AsyncTimeout* obj, TimeoutManager::timeout_type timeout)
```

| 层次（库）  | 函数                       | 使用时钟        | 备注                                      |
| ----------- | -------------------------- | --------------- | ----------------------------------------- |
| System Call | epoll_wait                 | CLOCK_MONOTONIC |                                           |
| libevent    | event_add                  | CLOCK_MONOTONIC | 传入relative time即可，背后用的是monotime |
| folly       | EventBase::scheduleTimeout | CLOCK_MONOTONIC |                                           |
|             | EventBase::runAfterDelay   | CLOCK_MONOTONIC |                                           |



## Reference

1. [[doc] nanosleep](https://man7.org/linux/man-pages/man2/nanosleep.2.html)

2. [[issue] std::condition_variable in bugzilla](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=41861#c20)

3. [[doc] pthread_condattr_setclock](https://linux.die.net/man/3/pthread_condattr_setclock)

4. [[code] pthread_cond_init](https://github.com/walac/glibc/blob/master/nptl/pthread_cond_init.c)





## Appendix

### 代码片段详解：

通过以上调用的总结可以发现，使用上模糊的点主要是通过条件变量进行通信的场景，pthread上提供的最基本的函数是可选的，在std和boost分别采用了不同的时钟。下面直接看实现的代码：

#### pthread_cond_t

存储控制`pthread_cond_timedwait`使用时钟的数据结构`pthread_cond_t`

```c++
/* Data structure for conditional variable handling.  The structure of
   the attribute type is not exposed on purpose.  */
typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data; // __nwaiters 存储了时钟的信息
  char __size[__SIZEOF_PTHREAD_COND_T];
  __extension__ long long int __align;
} pthread_cond_t;
```

#### std::condition_variable

std如何初始化`pthread_cond_t`

```c++
typedef pthread_cond_t __gthread_cond_t; // 1. 核心是初始化pthread_cond_t这个类
 
/// condition_variable
  class condition_variable
  {
    typedef chrono::system_clock	__clock_t;
    typedef __gthread_cond_t		__native_type;

#ifdef __GTHREAD_COND_INIT
    __native_type			_M_cond = __GTHREAD_COND_INIT; // 2. 在这里进行了初始化
#else
    __native_type			_M_cond;
#endif
	······
	}

#define __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER
/* Conditional variable handling.  */
#define PTHREAD_COND_INITIALIZER { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } } // 3. 具体初始化的参数
```

#### boost::conditional_variable

boost如何初始化`pthread_cond_t`

```c++
class condition_variable
    {
    private:
//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS
        pthread_mutex_t internal_mutex;
//#endif
        pthread_cond_t cond; // 1. 核心是初始化pthread_cond_t这个类

    public:
      BOOST_THREAD_NO_COPYABLE(condition_variable)
        condition_variable()
        {
            int res;
            ```省略初始化mutex
            res = pthread::cond_init(cond); // 2. 在这里进行了初始化
            ```省略后续判断
        }
     }
     
     

```

```c++
namespace boost
{
    namespace pthread
    {
      inline int cond_init(pthread_cond_t& cond) {

  #ifdef BOOST_THREAD_INTERNAL_CLOCK_IS_MONO
              pthread_condattr_t attr;
              int res = pthread_condattr_init(&attr);
              if (res)
              {
                return res;
              }
              pthread_condattr_setclock(&attr, CLOCK_MONOTONIC); // 3. 设置了时钟attr为MONO
              res=pthread_cond_init(&cond,&attr);
              pthread_condattr_destroy(&attr);
              return res;
  #else
              return pthread_cond_init(&cond,NULL);
  #endif

      }
    }
}
```

