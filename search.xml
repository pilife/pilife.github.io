<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你真的理解时钟吗？</title>
    <url>/2021/04/28/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E6%97%B6%E9%92%9F%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>在实际编程中，超时判断作为无处不在，但是其内在的原理，所用的时钟你真的了解吗？本文将带你了解常用的时钟及相关调用，让你在面对时间跳变时心中有底！</p>
<h2 id="时钟分类"><a class="markdownIt-Anchor" href="#时钟分类"></a> 时钟分类</h2>
<p>首先需要了解时钟有哪几种，通过阅读time.h文件，可以发现共定义了12种时钟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">ifdef</span> __USE_POSIX199309</span></span><br><span class="line"><span class="comment">/* Identifier for system-wide realtime clock.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_REALTIME		0</span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_MONOTONIC		1</span></span><br><span class="line"><span class="comment">/* High-resolution timer from the CPU.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_PROCESS_CPUTIME_ID	2</span></span><br><span class="line"><span class="comment">/* Thread-specific CPU-time clock.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_THREAD_CPUTIME_ID	3</span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock, not adjusted for frequency scaling.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_MONOTONIC_RAW		4</span></span><br><span class="line"><span class="comment">/* Identifier for system-wide realtime clock, updated only on ticks.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_REALTIME_COARSE	5</span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock, updated only on ticks.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_MONOTONIC_COARSE	6</span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock that includes time spent in suspension.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_BOOTTIME		7</span></span><br><span class="line"><span class="comment">/* Like CLOCK_REALTIME but also wakes suspended system.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_REALTIME_ALARM		8</span></span><br><span class="line"><span class="comment">/* Like CLOCK_BOOTTIME but also wakes suspended system.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_BOOTTIME_ALARM		9</span></span><br><span class="line"><span class="comment">/* Like CLOCK_REALTIME but in International Atomic Time.  */</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> CLOCK_TAI			11</span></span><br></pre></td></tr></table></figure>
<p>总结一下，时钟按以下几个维度进行区分：</p>
<ul>
<li>墙上时钟/单调时钟</li>
<li>系统时钟/线程进程时钟</li>
<li>是否只在Tick时更新</li>
<li>是否包含挂起时间</li>
<li>…</li>
</ul>
<p><strong><u>定义的12个时钟是以上一个或多个维度的组合</u></strong></p>
<p>本文主要关注的是最常用的<code>CLOCK_REALTIME</code>和<code>CLOCK_MONOTONIC</code>的使用</p>
<p><code>CLOCK_REALTIME</code>:</p>
<ul>
<li>epoch是(00:00:00 GMT, January 1, 1970)</li>
<li>以整个系统时间流逝进行累加（和以在CPU上运行的时间累加CLOCK_PROCESS_CPUTIME_ID区分）</li>
<li>需要和NTP进行同步，因为地球自转并不总是86400秒且时钟存在误差</li>
</ul>
<p><code>CLOCK_MONOTONIC</code>:</p>
<ul>
<li>epoch是随机值，不具备具体含义</li>
<li>以整个系统时间流逝进行累加</li>
<li>无需和NTP同步，用来测量一段任务的持续时间（比如超时）</li>
</ul>
<h2 id="时钟相关调用"><a class="markdownIt-Anchor" href="#时钟相关调用"></a> 时钟相关调用</h2>
<ol>
<li>线程阻塞，一段时间后恢复就绪</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># glibc (POSIX)</span></span><br><span class="line">sleep</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>层次（库）</th>
<th>函数</th>
<th>使用时钟</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>glibc (POSIX)</td>
<td>sleep/nanosleep</td>
<td>CLOCK_MONOTONIC</td>
<td>POSIX规范推荐使用CLOCK_REALTIME，但是跳变不会影响sleep时间<br />Linux实现使用的是CLOCK_MONOTONIC</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>线程阻塞，等待唤醒或者超时</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># glibc (POSIX)</span></span><br><span class="line">pthread_cond_timedwait</span><br><span class="line">pthread_cond_clockwait #<span class="meta"># since glibc 2.30</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># stdlibc++</span></span><br><span class="line">std::condition_variable::wait_for</span><br><span class="line">std::condition_variable::wait_until</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>层次（库）</th>
<th>函数</th>
<th>使用时钟</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>glibc (POSIX)</td>
<td>pthread_cond_timedwait</td>
<td>可选</td>
<td>通过pthread_condattr_setclock选择时钟</td>
</tr>
<tr>
<td></td>
<td>pthread_cond_clockwait</td>
<td>可选</td>
<td>since glibc 2.30</td>
</tr>
<tr>
<td>stdlibc++</td>
<td>std::condition_variable::wait_for</td>
<td>CLOCK_REALTIME</td>
<td>since gcc10变为CLOCK_MONOTONIC</td>
</tr>
<tr>
<td></td>
<td>std::condition_variable::wait_until</td>
<td>CLOCK_REALTIME</td>
<td>since gcc10变为CLOCK_MONOTONIC</td>
</tr>
<tr>
<td>boost</td>
<td>boost::condition_variable::wait_for</td>
<td>CLOCK_MONOTONIC</td>
<td></td>
</tr>
<tr>
<td></td>
<td>boost::condition_variable::wait_until</td>
<td>CLOCK_MONOTONIC</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="3">
<li>线程阻塞，等待fd就绪或者超时</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># System Call</span><br><span class="line">epoll_wait <span class="comment">// CLOCK_MONOTONIC</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># libevent</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">event_add</span><span class="params">(struct event *ev, <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta"># folly</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EventBase::scheduleTimeout</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    AsyncTimeout* obj, TimeoutManager::timeout_type timeout)</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>层次（库）</th>
<th>函数</th>
<th>使用时钟</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>System Call</td>
<td>epoll_wait</td>
<td>CLOCK_MONOTONIC</td>
<td></td>
</tr>
<tr>
<td>libevent</td>
<td>event_add</td>
<td>CLOCK_MONOTONIC</td>
<td>传入relative time即可，背后用的是monotime</td>
</tr>
<tr>
<td>folly</td>
<td>EventBase::scheduleTimeout</td>
<td>CLOCK_MONOTONIC</td>
<td></td>
</tr>
<tr>
<td></td>
<td>EventBase::runAfterDelay</td>
<td>CLOCK_MONOTONIC</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>线程阻塞，等待一段时间后恢复就绪
<ul>
<li>使用<code>sleep/nanosleep</code></li>
</ul>
</li>
<li>线程阻塞，等待唤醒或者超时
<ul>
<li>使用boost::condition_variable</li>
<li>gcc10及以上，可以使用std::condition_variable</li>
</ul>
</li>
<li>线程阻塞，等待fd就绪或者超时
<ul>
<li>folly::EventBase 放心食用</li>
</ul>
</li>
</ol>
<h2 id="未来计划"><a class="markdownIt-Anchor" href="#未来计划"></a> 未来计划</h2>
<p>后续如果遇到更多使用超时的场景会补充进来</p>
<p>另外关于以上三类情况背后系统调用里超时的实现原理后续会研究补充进来</p>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ol>
<li>
<p><a href="https://man7.org/linux/man-pages/man2/nanosleep.2.html">[doc] nanosleep</a></p>
</li>
<li>
<p><a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=41861#c20">[issue] std::condition_variable in bugzilla</a></p>
</li>
<li>
<p><a href="https://linux.die.net/man/3/pthread_condattr_setclock">[doc] pthread_condattr_setclock</a></p>
</li>
<li>
<p><a href="https://github.com/walac/glibc/blob/master/nptl/pthread_cond_init.c">[code] pthread_cond_init</a></p>
</li>
<li>
<p><a href="https://github.com/walac/glibc/tree/master/nptl">[code] pthread</a></p>
</li>
</ol>
<h2 id="appendix"><a class="markdownIt-Anchor" href="#appendix"></a> Appendix</h2>
<h3 id="代码片段详解"><a class="markdownIt-Anchor" href="#代码片段详解"></a> 代码片段详解：</h3>
<p>通过以上调用的总结可以发现，使用上模糊的点主要是通过条件变量进行通信的场景，pthread上提供的最基本的函数是可选的，在std和boost分别采用了不同的时钟。下面直接看实现的代码：</p>
<h4 id="pthread_cond_t"><a class="markdownIt-Anchor" href="#pthread_cond_t"></a> pthread_cond_t</h4>
<p>存储控制<code>pthread_cond_timedwait</code>使用时钟的数据结构<code>pthread_cond_t</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Data structure for conditional variable handling.  The structure of</span></span><br><span class="line"><span class="comment">   the attribute type is not exposed on purpose.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">int</span> __lock;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __futex;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __total_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __wakeup_seq;</span><br><span class="line">    __extension__ <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __woken_seq;</span><br><span class="line">    <span class="keyword">void</span> *__mutex;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __nwaiters; <span class="comment">// __nwaiters 存储了时钟的信息</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> __broadcast_seq;</span><br><span class="line">  &#125; __data; </span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_COND_T];</span><br><span class="line">  __extension__ <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_cond_t</span>;</span><br></pre></td></tr></table></figure>
<p>下面看<code>__pthread_cond_init</code>如何对该变量进行初始化，可见是通过读取<code>cond_attr.value</code>的倒数第二位设置到<code>__nwaiters</code>中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __pthread_cond_init (cond, cond_attr)</span><br><span class="line">     <span class="keyword">pthread_cond_t</span> *cond;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *cond_attr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread_condattr</span> *<span class="title">icond_attr</span> =</span> (struct pthread_condattr *) cond_attr;</span><br><span class="line"></span><br><span class="line">  cond-&gt;__data.__lock = LLL_LOCK_INITIALIZER;</span><br><span class="line">  cond-&gt;__data.__futex = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__nwaiters = (icond_attr != <span class="literal">NULL</span>  <span class="comment">// 看这里，设置nwaiters</span></span><br><span class="line">			     ? ((icond_attr-&gt;value &gt;&gt; <span class="number">1</span>)</span><br><span class="line">				&amp; ((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>))</span><br><span class="line">			     : CLOCK_REALTIME);</span><br><span class="line">  cond-&gt;__data.__total_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__wakeup_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__woken_seq = <span class="number">0</span>;</span><br><span class="line">  cond-&gt;__data.__mutex = (icond_attr == <span class="literal">NULL</span> || (icond_attr-&gt;value &amp; <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line">			  ? <span class="literal">NULL</span> : (<span class="keyword">void</span> *) ~<span class="number">0l</span>);</span><br><span class="line">  cond-&gt;__data.__broadcast_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LIBC_PROBE</span> (cond_init, <span class="number">2</span>, cond, cond_attr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后看<code>pthread_condattr_setclock</code>如何设置<code>cond_attr</code>相应位为clock id，非常简单，保存在了大端序倒数第二位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// macro in libpthread/nptl/sysdeps/unix/sysv/linux/internaltypes.h</span></span><br><span class="line"><span class="comment">/* The __NWAITERS field is used as a counter and to house the number</span></span><br><span class="line"><span class="comment">   of bits for other purposes.  COND_CLOCK_BITS is the number</span></span><br><span class="line"><span class="comment">   of bits needed to represent the ID of the clock.  COND_NWAITERS_SHIFT</span></span><br><span class="line"><span class="comment">   is the number of bits reserved for other purposes like the clock.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COND_CLOCK_BITS		1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COND_NWAITERS_SHIFT	1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setclock</span> <span class="params">(attr, clock_id)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">pthread_condattr_t</span> *attr</span>;</span><br><span class="line">     <span class="keyword">clockid_t</span> clock_id;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Only a few clocks are allowed.  */</span></span><br><span class="line">  <span class="keyword">if</span> (clock_id != CLOCK_MONOTONIC &amp;&amp; clock_id != CLOCK_REALTIME)</span><br><span class="line">    <span class="comment">/* If more clocks are allowed some day the storing of the clock ID</span></span><br><span class="line"><span class="comment">       in the pthread_cond_t structure needs to be adjusted.  */</span></span><br><span class="line">    <span class="keyword">return</span> EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the value fits in the bits we reserved.  */</span></span><br><span class="line">  <span class="built_in">assert</span> (clock_id &lt; (<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *valuep = &amp;((struct pthread_condattr *) attr)-&gt;value;</span><br><span class="line"></span><br><span class="line">  *valuep = ((*valuep &amp; ~(((<span class="number">1</span> &lt;&lt; COND_NWAITERS_SHIFT) - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>))</span><br><span class="line">	     | (clock_id &lt;&lt; <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<p><code>pthread_cond_t.__nwaiters</code>存储了时钟信息，通过<code>pthread_condattr_setclock</code>和<code>__pthread_cond_init</code>进行设置</p>
<h4 id="stdcondition_variable"><a class="markdownIt-Anchor" href="#stdcondition_variable"></a> std::condition_variable</h4>
<p>std如何初始化<code>pthread_cond_t</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">pthread_cond_t</span> <span class="keyword">__gthread_cond_t</span>; <span class="comment">// 1. 核心是初始化pthread_cond_t这个类</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/// condition_variable</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">condition_variable</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> chrono::system_clock	<span class="keyword">__clock_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">__gthread_cond_t</span>		__native_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GTHREAD_COND_INIT</span></span><br><span class="line">    __native_type			_M_cond = __GTHREAD_COND_INIT; <span class="comment">// 2. 在这里进行了初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __native_type			_M_cond;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	······</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __GTHREAD_COND_INIT PTHREAD_COND_INITIALIZER</span></span><br><span class="line"><span class="comment">/* Conditional variable handling.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTHREAD_COND_INITIALIZER &#123; &#123; 0, 0, 0, 0, 0, (void *) 0, 0, 0 &#125; &#125; <span class="comment">// 3. 具体初始化的参数</span></span></span><br></pre></td></tr></table></figure>
<p>小结：</p>
<p><code>std::condition_variable</code>的<code>pthread_cond_t.__nwaiters</code>初始化为0，即为CLOCK_REALTIME</p>
<h4 id="boostconditional_variable"><a class="markdownIt-Anchor" href="#boostconditional_variable"></a> boost::conditional_variable</h4>
<p>boost如何初始化<code>pthread_cond_t</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">condition_variable</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//#if defined BOOST_THREAD_PROVIDES_INTERRUPTIONS</span></span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> internal_mutex;</span><br><span class="line"><span class="comment">//#endif</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 1. 核心是初始化pthread_cond_t这个类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">BOOST_THREAD_NO_COPYABLE</span>(condition_variable)</span><br><span class="line">        <span class="built_in">condition_variable</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            ```省略初始化mutex</span><br><span class="line">            res = pthread::<span class="built_in">cond_init</span>(cond); <span class="comment">// 2. 在这里进行了初始化</span></span><br><span class="line">            ```省略后续判断</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> boost</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> pthread</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>&amp; cond)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> BOOST_THREAD_INTERNAL_CLOCK_IS_MONO</span></span><br><span class="line">              <span class="keyword">pthread_condattr_t</span> attr;</span><br><span class="line">              <span class="keyword">int</span> res = <span class="built_in">pthread_condattr_init</span>(&amp;attr);</span><br><span class="line">              <span class="keyword">if</span> (res)</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">pthread_condattr_setclock</span>(&amp;attr, CLOCK_MONOTONIC); <span class="comment">// 3. 设置了时钟attr为MONO</span></span><br><span class="line">              res=<span class="built_in">pthread_cond_init</span>(&amp;cond,&amp;attr);</span><br><span class="line">              <span class="built_in">pthread_condattr_destroy</span>(&amp;attr);</span><br><span class="line">              <span class="keyword">return</span> res;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：</p>
<p><code>boost::conditional_variable</code>的<code>pthread_cond_t.__nwaiters</code>初始化为1，即为CLOCK_MONOTONIC</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>如何计算分布式系统的可靠性</title>
    <url>/2021/05/10/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
    <content><![CDATA[<h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2>
<p>泊松分布：描述<strong>单位时间内</strong>随机事件发生的<strong>次数</strong>的概率分布</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo>=</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msup><mi>e</mi><mrow><mo>−</mo><mi>λ</mi></mrow></msup><msup><mi>λ</mi><mi>k</mi></msup></mrow><mrow><mi>k</mi><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(X=k)=\frac{e^{-\lambda}\lambda^k}{k!}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.212108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.526108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">λ</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="问题建模"><a class="markdownIt-Anchor" href="#问题建模"></a> 问题建模</h2>
<h3 id="问题定义"><a class="markdownIt-Anchor" href="#问题定义"></a> 问题定义</h3>
<p>简略描述：分布式存储系统年失效率</p>
<p>详细描述：以硬盘为存储数据的基本物理单位，一年时间内，硬盘故障导致数据丢失的概率</p>
<h3 id="问题拆解"><a class="markdownIt-Anchor" href="#问题拆解"></a> 问题拆解</h3>
<ol>
<li>单个硬盘单位时间故障概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></li>
<li><code>K</code>个硬盘一段时间<code>T</code>内故障概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_a(T,K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></li>
<li>损坏的<code>K</code>个硬盘恰好造成数据丢失的概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></li>
<li><code>T</code>时间内，硬盘故障导致数据丢失的概率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>c</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_c(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></li>
</ol>
<h3 id="问题求解"><a class="markdownIt-Anchor" href="#问题求解"></a> 问题求解</h3>
<h4 id="lambda"><a class="markdownIt-Anchor" href="#lambda"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></h4>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>通过统计即可得到，设为<code>t</code>的单位时间(设为1小时)内发生磁盘损坏的平均次数，根据google的统计，磁盘的年失败率(AFR: Fnnualized Failure Rate)如下图所示，我们取一个平均值4来进行计算，那么就是0.0004566</p>
<img data-src="https://blog-1251491272.cos.ap-beijing.myqcloud.com/uPic/afr_age.png" style="zoom: 33%;" />
<h4 id="p_atk"><a class="markdownIt-Anchor" href="#p_atk"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_a(T,K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></h4>
<p>通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>以及泊松分布的公式，可以计算得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_a(T,K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></p>
<h4 id="p_bk"><a class="markdownIt-Anchor" href="#p_bk"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></h4>
<p>通过数据复制方式和副本放置策略，可以建模得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>，数据复制方式分为多副本和EC，副本放置策略可以是固定位置放置，可以是随机不重复放置</p>
<blockquote>
<p>Q：关于随机不重复放置，是否能保证有足够的放置策略让副本放置不重复呢？</p>
<p>A：随着集群规模增大，可容纳数据量呈线性增长，放置策略数量呈幂增长，因此可以认为放置策略远远大于需要放置的数据量（数据复制的基本单位是副本）</p>
<p>以下证明：</p>
<p>假设一个磁盘中副本数量为100，副本/EC数为N，集群中磁盘的数量为D</p>
<p>可容纳数据量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>∗</mo><mn>100</mn><mi mathvariant="normal">/</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">D * 100 / N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></p>
<p>放置策略数量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>D</mi><mi mathvariant="normal">/</mi><mi>N</mi><msup><mo stretchy="false">)</mo><mi>N</mi></msup></mrow><annotation encoding="application/x-tex">(D/N)^N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span></span></span></span></span></span></span></p>
<p><img data-src="https://blog-1251491272.cos.ap-beijing.myqcloud.com/uPic/300px-Exponential.svg-20210510195955279.png" alt="img" /></p>
</blockquote>
<h3 id="p_ct"><a class="markdownIt-Anchor" href="#p_ct"></a> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>c</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_c(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span></h3>
<p>通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_a(T,K)*P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>可以得到<code>T</code>时间内损坏磁盘数量为<code>K</code>时，数据丢失的概率。将所有可能的<code>K</code>计算得到的概率相加即可得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>c</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_c(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>，计算公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><msub><mi>P</mi><mi>a</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo separator="true">,</mo><mi>K</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>K</mi><mo>≥</mo><mi>m</mi><mi>i</mi><mi>n</mi><mtext> </mtext><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>r</mi><mi>e</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>a</mi><mtext> </mtext><mi>t</mi><mi>o</mi><mtext> </mtext><mi>b</mi><mi>e</mi><mtext> </mtext><mi>r</mi><mi>e</mi><mi>m</mi><mi>o</mi><mi>v</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">\sum P_a(T,K)*P_b(K) \\
K \ge min\ number\ of\ replica\ to\ be\ removed
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mspace"> </span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span></span></p>
<h2 id="细节补充"><a class="markdownIt-Anchor" href="#细节补充"></a> 细节补充</h2>
<p>通过对问题进行建模，发现唯一不确定的地方就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>的计算，不同的数据复制方式，如多副本和EC；以及不同的副本放置策略，如固定位置和随机不重复放置，都会导致<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>b</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_b(K)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span>的计算不同，以下对各类场景进行具体分析</p>
<h3 id="多副本场景"><a class="markdownIt-Anchor" href="#多副本场景"></a> 多副本场景</h3>
<h3 id="ec场景"><a class="markdownIt-Anchor" href="#ec场景"></a> EC场景</h3>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ol>
<li><a href="http://oceanbase.org.cn/?p=151">[blog] OceanBase 磁盘故障与存储系统的年失效率估算</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/47505443">[blog] 如何量化分布式存储系统的可靠性</a></li>
<li><a href="https://storagemojo.com/2007/02/19/googles-disk-failure-experience/">[blog] Google’s Disk Failure Experience</a></li>
<li><a href="http://static.googleusercontent.com/media/research.google.com/en//archive/disk_failures.pdf">[paper] Failure Trends in a Large Disk Drive Population</a></li>
</ol>
]]></content>
      <categories>
        <category>概率论应用</category>
      </categories>
      <tags>
        <tag>可靠性</tag>
        <tag>概率论</tag>
      </tags>
  </entry>
</search>
